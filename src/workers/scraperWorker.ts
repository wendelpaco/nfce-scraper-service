/* eslint-disable no-console */
import { Worker } from "bullmq";
import { getScraperByCode } from "../scrapers/scraperRegistry";
import prisma from "../utils/prisma";
import { openPage, getAllPages } from "../utils/browserInstance";
import { solvePageCaptchas } from "../core/solveRecaptchas";
import { EventEmitter } from "events";
import { captchaQueue, redisConfig } from "../jobs/queue";
import { logger } from "../utils/logger";
import axios from "axios";

EventEmitter.defaultMaxListeners = 50;

type JobStatus = "DONE" | "INVALID" | "BLOCKED" | "ERROR";

function classifyErrorOrContent(error: unknown, pageText?: string): JobStatus {
  const errorStr = (
    error instanceof Error ? error.message : String(error)
  ).toLowerCase();
  const contentStr = pageText?.toLowerCase() || "";

  // if (contentStr.trim().length === 0) {
  //   return "INVALID"; // P√°gina sem conte√∫do esperado deve ser considerada inv√°lida
  // }

  if (
    contentStr.includes("secretaria de estado de fazenda do rio de janeiro") ||
    contentStr.includes("bloqueia acessos provenientes desses endere√ßos ip") ||
    errorStr.includes("blocked") ||
    errorStr.includes("captcha")
  ) {
    return "BLOCKED";
  }

  if (
    contentStr.includes("n√£o foi poss√≠vel validar o acesso") ||
    contentStr.includes("rejei√ß√£o: consumo indevido") ||
    contentStr.includes("656-rejei√ß√£o: consumo indevido.") ||
    errorStr.includes("invalid") ||
    errorStr.includes("n√£o encontrado")
  ) {
    return "INVALID";
  }

  if (error && errorStr.trim().length > 0) return "ERROR";

  return "DONE"; // Conte√∫do parece v√°lido
}

export const scraperWorker = new Worker(
  "scraperQueue",
  async (job) => {
    const { url, stateCode, jobId } = job.data;

    const urlQueueRecord = await prisma.urlQueue.findFirst({
      where: {
        id: jobId,
        status: { in: ["PENDING", "ERROR"] },
      },
    });

    if (!urlQueueRecord) {
      logger(`‚ö†Ô∏è Job ${job.id} n√£o est√° pendente. Ignorando processamento.`);
      return;
    }

    try {
      const scraper = getScraperByCode(stateCode);
      const { page } = await openPage(url);

      await page
        .waitForSelector("#tabResult tr", { timeout: 30000 })
        .catch(() => {
          logger(
            "[DEBUG] Timeout esperando seletor #tabResult tr. Pode n√£o ter carregado.",
          );
        });

      // Verifica√ß√£o expl√≠cita de iframe de reCAPTCHA para melhorar detec√ß√£o
      const recaptchaFrame = page
        .frames()
        .find((frame) =>
          frame.url().includes("https://www.google.com/recaptcha/api2/anchor"),
        );

      if (recaptchaFrame) {
        logger(
          "üéØ reCAPTCHA detectado via iframe na p√°gina. Tentando resolver...",
        );
        const captchaResult = await solvePageCaptchas(page);
        if (captchaResult.error) {
          logger(`‚ö†Ô∏è Erro ao resolver captcha: ${captchaResult.error}`);
        } else if (captchaResult.solved) {
          logger("‚úÖ Captcha resolvido com sucesso.");
        } else {
          logger("‚ö†Ô∏è reCAPTCHA detectado, mas n√£o foi poss√≠vel resolver.");
        }
      } else {
        logger("‚ÑπÔ∏è Nenhum reCAPTCHA detectado na p√°gina via iframe.");
      }

      logger(
        `[DEBUG] Aguardando seletor #tabResult tr para garantir carregamento da p√°gina...`,
      );
      let pageText = "";
      try {
        pageText = await page.evaluate(() => {
          const avisoErro = document.querySelector(".avisoErro");
          if (avisoErro && avisoErro.textContent?.trim()) {
            return avisoErro.textContent.trim();
          }
          return document.body?.innerText || "";
        });
      } catch (err) {
        logger("‚ö†Ô∏è Erro ao extrair innerText do body:", err);
        pageText = "";
      }
      logger(
        "[DEBUG] Texto extra√≠do da p√°gina:",
        pageText.substring(0, 80).replace(/\n/g, " "),
      );

      // Classifica o conte√∫do da p√°gina antes de tentar resolver captchas
      const preCheckStatus = classifyErrorOrContent(null, pageText);
      logger(`[DEBUG] Status pr√©-check da p√°gina: ${preCheckStatus}`);

      if (preCheckStatus === "DONE") {
        const hasTable = await page.$("#tabResult tr");
        if (hasTable) {
          logger(
            `‚úÖ P√°gina carregada com sucesso para job ${job.id}. Nota fiscal parece v√°lida.`,
          );
        } else {
          logger(
            `‚ö†Ô∏è Elemento esperado (#tabResult tr) n√£o encontrado mesmo ap√≥s status DONE. Marcando como ERROR.`,
          );
          await prisma.urlQueue.update({
            where: { id: jobId },
            data: {
              status: "ERROR",
              lastErrorMessage: `${pageText} - Elemento #tabResult tr n√£o encontrado na p√°gina.`,
            },
          });
          await page.close();
          throw new Error("Elemento #tabResult tr n√£o encontrado na p√°gina.");
        }
      }

      if (preCheckStatus === "INVALID") {
        const lowerText = pageText.toLowerCase();

        // Se for erro que exige resolver captcha, encaminha para captchaQueue
        if (
          lowerText.includes("n√£o foi poss√≠vel validar o acesso") ||
          lowerText.includes("erro no captcha")
        ) {
          logger(`‚û°Ô∏è Redirecionando job ${job.id} para fila de CAPTCHA.`);

          await captchaQueue.add("captchaSolver", {
            url,
            jobId,
            originalStateCode: stateCode,
          });

          await prisma.urlQueue.update({
            where: { id: jobId },
            data: {
              status: "WAITING_CAPTCHA",
              lastErrorMessage: `${pageText} - Aguardando resolu√ß√£o alternativa via CAPTCHA.`,
            },
          });

          await page.close();
          return;
        }

        logger(
          `üö´ Conte√∫do inv√°lido detectado para job ${job.id}. Removendo da fila.`,
        );
        await prisma.urlQueue.update({
          where: { id: jobId },
          data: {
            status: "INVALID",
            lastErrorMessage: `${pageText} - Conte√∫do inv√°lido detectado na p√°gina.`,
          },
        });
        await page.close();
        return;
      }

      if (preCheckStatus === "BLOCKED") {
        logger(
          `‚è≥ Bloqueio tempor√°rio detectado para job ${job.id}. Reagendando para reprocessamento.`,
        );

        await prisma.urlQueue.update({
          where: { id: jobId },
          data: {
            status: "BLOCKED",
            lastErrorMessage: `${pageText} - Bloqueio tempor√°rio detectado na p√°gina.`,
          },
        });

        await page.close();

        // Faz o worker lan√ßar erro controlado para permitir reprocessamento via retry
        throw new Error("BLOCKED_TEMPORARILY");
      }

      await page.waitForTimeout(2000); // Aguarda carregamento inicial da p√°gina

      const result = await scraper.scrape(page);

      await page.close();

      if (!urlQueueRecord || urlQueueRecord.status !== "PENDING") {
        logger(
          `‚ö†Ô∏è Ignorando job ${job.id} com status n√£o pendente ou inexistente.`,
        );
        return;
      }

      const metadata = {
        ...result.metadata,
        items: result.items,
        totals: result.totals,
      };

      const pushedData = {
        status: "DONE",
        url,
        webhookUrl: urlQueueRecord?.webhookUrl || null,
        metadata,
      };

      await prisma.notaResult.create({
        data: {
          url,
          jsonData: JSON.parse(JSON.stringify({ metadata })),
          webhookUrl: urlQueueRecord?.webhookUrl || null,
          urlQueueId: jobId,
        },
      });

      await prisma.urlQueue.update({
        where: { id: jobId },
        data: { status: "DONE", lastErrorMessage: null },
      });

      if (urlQueueRecord?.webhookUrl) {
        logger(`üöÄ Tentando enviar webhook para: ${urlQueueRecord.webhookUrl}`);
        try {
          const response = await axios.post(
            urlQueueRecord.webhookUrl!,
            pushedData,
          );
          logger(`‚úÖ Webhook enviado com sucesso! Status: ${response.status}`);
        } catch (err) {
          console.error(
            `‚ùå Falha ao enviar webhook para: ${urlQueueRecord.webhookUrl}`,
            err,
          );
        }
      } else {
        console.warn(`‚ö†Ô∏è Nenhum webhookUrl configurado para job ${job.id}`);
      }

      return pushedData;
    } catch (error) {
      console.error(`‚ùå Job ${job.id} falhou:`, error);

      // Tenta avaliar se o erro indica bloqueio tempor√°rio ou definitivo
      let pageText = "";
      try {
        const pages = await getAllPages();
        for (const page of pages) {
          try {
            const content = await page.content();
            if (
              content.includes(
                "SECRETARIA DE ESTADO DE FAZENDA DO RIO DE JANEIRO",
              ) ||
              content
                .toLowerCase()
                .includes("bloqueia acessos provenientes desses endere√ßos ip")
            ) {
              logger(
                `üî¥ Detec√ß√£o de bloqueio de IP para job ${job.id}, fechando a aba...`,
              );
              await page.close();
            }
          } catch (innerError) {
            logger(
              `‚ö†Ô∏è N√£o foi poss√≠vel analisar ou fechar a p√°gina:`,
              innerError,
            );
            try {
              await page.close();
            } catch (closeError) {
              logger(`‚ö†Ô∏è Erro ao fechar p√°gina ap√≥s falha:`, closeError);
            }
          }
        }

        // Pega o texto de uma das p√°ginas abertas para an√°lise
        if (pages.length > 0) {
          pageText = await pages[0].evaluate(() => document.body.innerText);
        }
      } catch (pageCloseError) {
        console.error(
          `‚ùå Erro ao tentar obter p√°ginas ap√≥s falha no job ${job.id}:`,
          pageCloseError,
        );
      }

      const finalStatus = classifyErrorOrContent(error, pageText);

      await prisma.urlQueue.update({
        where: { id: jobId },
        data: {
          status: finalStatus,
          lastErrorMessage:
            error instanceof Error
              ? `${pageText} - ${error.message}`
              : `${pageText} - ${String(error)}`,
        },
      });

      // Fecha p√°ginas abertas muito antigas para liberar mem√≥ria
      try {
        const pages = await getAllPages();
        const now = Date.now();

        for (const page of pages) {
          try {
            const target = page.target();
            const creationTime = (target as any)._targetInfo
              ?.targetCreationTime;
            const creationTimestamp = creationTime
              ? new Date(creationTime).getTime()
              : null;
            const duration = creationTimestamp ? now - creationTimestamp : null;

            if (duration !== null && duration > 2 * 60 * 1000) {
              logger(
                `üßπ P√°gina aberta h√° mais de 2 minutos detectada. Fechando...`,
              );
              await page.close();
            }
          } catch (err) {
            logger(`‚ö†Ô∏è Erro ao tentar fechar p√°gina antiga:`, err);
          }
        }
      } catch (cleanupError) {
        console.error(
          `‚ö†Ô∏è Erro ao tentar realizar limpeza de abas antigas:`,
          cleanupError,
        );
      }

      throw error;
    }
  },
  {
    connection: redisConfig,
    concurrency: parseInt(process.env.WORKER_CONCURRENCY || "2", 10),
    lockDuration: parseInt(process.env.WORKER_LOCK_DURATION || "600000", 10),
    stalledInterval: parseInt(
      process.env.WORKER_STALLED_INTERVAL || "120000",
      10,
    ),
    maxStalledCount: parseInt(process.env.WORKER_MAX_STALLED || "3", 10),
  },
);

scraperWorker.on("completed", (job) => {
  logger(`‚úÖ Job ${job.id} finalizado`);
});

scraperWorker.on("failed", (job, err) => {
  console.error(`‚ùå Job ${job?.id} falhou:`, err);
});
